<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.17"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>ECP-VELOC Components: Overview</title>
    <!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
    <!-- <script type="text/javascript" src="jquery.js"></script> -->
    <!-- <script type="text/javascript" src="dynsections.js"></script> -->
    <!--  -->
    <!--  -->
    <!--  -->
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="new_stylesheet.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr style="height: 56px;">
              <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">ECP-VELOC Components
                </div>
                <div id="projectbrief">User documentation for all components</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
      <div id="main-nav">
        <ul id="main-menu" class="sm sm-dox">
          <li><a href="index.html"><span>Main Page</span></a></li>
          <li><a href="modules.html"><span>Components</span></a></li>
          <li><a href="files.html"><span>All Files</span></a></li>
        </ul>
      </div>
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>AXL defines a common interface for transferring files between layers in a storage hierarchy. It abstracts vendor-specific APIs and provides synchronous and asynchronous methods using POSIX. One creates a transfer object, defining the transfer type, and then one adds files to the transfer. Once all files have been added, one initiates the transfer and can then later test or wait for its completion. The library optionally records the state of ongoing transfers, so that they can be identified or terminated even if the process that initiated the transfer has been restarted.</p>
<p>For an example of how to use AXL, see <a href="../test/test_axl_sync.c">test_axl_sync.c</a></p>
<p>For more detailed use of the API, refer to <a href="../src/axl.h">axl.h</a>.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Initializing AXL</h1>
<p>Before calling AXL funcitons, one must first initialize the library by calling AXL_Init. One can optionally provide the path to a file where AXL can persist its state. If given a state file, AXL can recover its state upon restarting the process. If no state files is needed, one may pass NULL in place of the path name.</p>
<p>One must call AXL_Finalize to shut down the library.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Setting options</h1>
<p>AXL contains several tunable options that control how files are transferred. These are settable using the AXL_Config function which takes as its single argument a pointer to a kvtree of option-value pairs. On success a non-NULL pointer is returned, on failure NULL is returned. Calling AXL_Config with a NULL pointer instead returns a kvtree with the current values of all settable configuration options. It must be freed used kvtree_delete after use. A subset of options can also be set for individual AXL transfers by passing them in a subtree "id" of the kvtree indexed by their integer transfer id. These options are included in the result of AXL_Config as an "id" subtree. By default a transfer will use the values of the global configuration options present at the time the transfer is created. Changing options of a transfer after is has been dispatched results in undefined behavior.</p>
<p>An example kvtree may look like this: </p><pre class="fragment">+- FILE_BUF_SIZE
|  +- 1000000
+- DEBUG
|  +- 0
+- id
   +- 42
   |  +- FILE_BUF_SIZE
   |  |  +- 1048576
   |  +- COPY_METADATA 
   |     +- 1
   +- 1
      +- FILE_BUF_SIZE
         +- 65536
</pre><p><a class="el" href="axl_8h.html" title="asynchronous transfer library">axl.h</a> defines symbolic names for all parameter which should be used instead of the immediate strings whenever possible to avoid typos and runtime errors.</p>
<p>The current set of configuariont options including their default value is (prefix Name by AXL_KEY_CONFIG_ for symbolic name):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name </th><th class="markdownTableHeadRight">Type </th><th class="markdownTableHeadRight">Default </th><th class="markdownTableHeadCenter">Per transfer </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FILE_BUF_SIZE </td><td class="markdownTableBodyRight">Byte count </td><td class="markdownTableBodyRight">1048576 </td><td class="markdownTableBodyCenter">Yes </td><td class="markdownTableBodyNone">Specify the number of bytes to use for internal buffers when copying files between source and destination.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">DEBUG </td><td class="markdownTableBodyRight">Boolean </td><td class="markdownTableBodyRight">0 </td><td class="markdownTableBodyCenter">No </td><td class="markdownTableBodyNone">Set to 1 to have AXL print debug messages to stdout, set to 0 for no output.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MKDIR </td><td class="markdownTableBodyRight">Boolean </td><td class="markdownTableBodyRight">1 </td><td class="markdownTableBodyCenter">Yes </td><td class="markdownTableBodyNone">Specifies whether the destination file system supports the creation of directories (1) or not (0).  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">COPY_METADATA </td><td class="markdownTableBodyRight">Boolean </td><td class="markdownTableBodyRight">0 </td><td class="markdownTableBodyCenter">Yes </td><td class="markdownTableBodyNone">Whether file metadata like timestamp and permission bits should also be copied.  </td></tr>
</table>
<p>Thread safety: setting the DEBUG or any per-transfer configuration value after the transfer has been dispatched entails a race contion between the main thread and the worker threads. Changing configuration options after a transfer has been dispatched is not supported.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Transferring files</h1>
<p>Regardless of the transfer type, the basic control flow of a transfer is always:</p><ol type="1">
<li>AXL_Create - allocate a new transfer object, providing its type and a name</li>
<li>AXL_Add - add a file to a transfer object, giving both source and destination path</li>
<li>AXL_Dispatch - start the transfer</li>
<li>AXL_Test - optional, non-blocking test for whether AXL_Wait will block</li>
<li>AXL_Cancel - optionally cancel a dispatched transfer</li>
<li>AXL_Wait - wait for transfer to complete</li>
<li>AXL_Free - free resources associated with transfer object allocated in AXL_Create</li>
</ol>
<p>AXL_Create returns a transfer id that is the identifier for the transfer object for most other calls. It returns -1 if it fails to create a transfer object. The name is meant to serve as a user-friendly string.</p>
<p>One may add multiple files to a transfer, and a transfer having zero files is also valid.</p>
<p>One may cancel an outstanding transfer by calling AXL_Cancel between AXL_Dispatch and AXL_Wait. One must still call AXL_Wait on a cancelled transfer.</p>
<p>AXL_Test does not indicate whether a transfer succeeded. It indicates whether a call to AXL_Wait will block. One must call AXL_Wait to identify whether a transfer succeeded or failed.</p>
<p>It is valid to free a transfer object if it has not been dispatched.</p>
<p>One can call AXL_Stop to terminate any and all outstanding transfers without having to know the status, identifiers, or names of those transfers. One can not call wait or free on transfers that were terminated with AXL_Stop.</p>
<p>If a transfer fails, partially transferred files are not removed from the destination.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Transfer types</h2>
<ul>
<li>AXL_XFER_SYNC - this is a synchronous transfer, which does not return until the files have been fully copied. It uses POSIX I/O to directly read/write files.</li>
<li>AXL_XFER_PTHREAD - Like AXL_XFER_SYNC, but use multiple threads to do the copy.</li>
<li>AXL_XFER_ASYNC_BBAPI - this method uses <a href="https://github.com/IBM/CAST">IBM's Burst Buffer API</a> to transfer files. IBM's system software then takes over to move data in the background. It's actually using NVMeoF, reading data from the local SSD from a remote node, so that the compute node is not really bothered once started. If either the source or destination filesystems don't support the BBAPI transfers, AXL will fall back to using a AXL_XFER_PTHREAD transfer instead.</li>
<li>AXL_XFER_ASYNC_DW - this method uses <a href="https://www.cray.com/products/storage/datawarp">Cray's Datawarp API</a>.</li>
<li>AXL_XFER_DEFAULT - Let AXL choose the fastest transfer type that is compatible with all VeloC transfers. This may or may not be the node's native transfer library.</li>
<li>AXL_XFER_NATIVE - Use the node's native transfer library (like IBM Burst Buffer or Cray DataWarp) for transfers. These native libraries may or may not support all VeloC transfers. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
